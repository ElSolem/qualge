[{"ver":"0.1","info":{"id":"ctVyDt","date":"1700805005","viewed":1489,"name":"Book of Light(life)","username":"ElSolem","description":"folding horizons :: looks better in 3D :: https://cineshader.com/view/ctVyDt :: after most recent change you really can't see on here, but this is the basic effect I wanted. Follow the cineshader link for full effect :: Sidis' Checkerboard","likes":1,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool Alakazan(float value1, float value2)\n{\n    return (value1 == value2) || (value1 != value2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float cosX = cos(uv.x + iTime);\n    float sinY = sin(uv.y + iTime);\n    float tan1_1 = tan(1.1 * cosX / sinY);\n    float tan9_9 = tan(9.9 * cosX * sinY);\n    float tan0_0 = tan(0.0 * cosX + sinY);\n\n    bool caseCraz = (tan1_1 <= tan9_9 || (tan1_1 * tan9_9 <= tan0_0));\n\n    // Alakazan logic\n    bool alakazanResult = Alakazan(cosX, sinY);\n\n    // change equality to change look\n    if (caseCraz && alakazanResult)\n    {\n        // Output to screen\n        fragColor = vec4(cosX, sinY, tan1_1, 1.); // Adjusted layout\n    }\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"cdKfW3","date":"1698715683","viewed":132,"name":"Boxes and Rings","username":"ElSolem","description":"ring light: https://www.shadertoy.com/view/mtyGWy\nboxes: https://www.shadertoy.com/view/cdKBDy\nxy = p.x / p.y :: secret sauce","likes":4,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://iquilezles.org/articles/palettes/\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec4 applyAlakazan(vec2 uv0) {\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 4.0; i++) {\n        uv0 = fract(uv0 * 1.5) - 0.5;\n\n        float d = length(uv0) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.0;\n\n    if (abs(xy) < abs(threshold)) {\n        vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n        fragColor = applyAlakazan(uv);\n    } else {\n        int i;\n        for (vec2 c = iResolution.xy, u = (roundEven(fragCoord) - c * 0.5) / c.y, p, z = p + 2e1;\n             z.x < 1e2 && (i = int(p) ^ int(p.y) ^ int(z)) % 93 % 43 < 32;\n             p = u * z + iTime * vec2(2, 9)) {\n            c = fract(-p * sign(u)) / abs(u);\n            z += min(min(c, c.yx), fract(-z)) + 2e-5;\n            fragColor.rgb = (1e2 - z.x) * (2.0 - cos(vec3(i /= 3, i + 5, i + 4)));\n        }\n\n        fragColor /= 2e2 + fwidth(fragColor.g) * 5e2;\n    }\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"mdVfDK","date":"1698682939","viewed":126,"name":"Bridge to Infinity || ft DoMa","username":"ElSolem","description":"Polyrefractals working with pentafractals. Fractal Party!!\nxy = p.x / p.y :: secret sauce","likes":0,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec2 translate(vec2 p, vec2 offset)\n{\n    return p - offset;\n}\n\nvec2 rotate(vec2 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 R = mat2(c, -s, s, c);\n    return R * p;\n}\n\nvec2 mirror(vec2 p, float degree)\n{\n    const float tau = pi * 2.0;\n    const float piHalf = 1.57079632679489661923;\n    float angle = tau / degree;\n    float theta = atan(p.y, p.x) + piHalf + angle / 2.0;\n    float turn = floor(theta / angle) * angle;\n    return rotate(p, turn);\n}\n\nvec3 draw(vec3 buffer, float d, float r, vec3 color)\n{\n    float up = min(iResolution.x, iResolution.y);\n    d = up * d;\n    r = r * up / 360.0;\n    r = clamp(r, 1.5, 10000.0);\n    float aa = fwidth(d);\n    return mix(buffer, color, 1.0 - smoothstep(r - aa, r + aa / 2.0, d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float xy = p.x / p.y;\n    float threshold = 1.;\n\n    if (sqrt(xy) == sqrt(p.x * p.y))\n    {\n        vec2 coord = fragCoord - iResolution.xy / 2.0;\n        vec2 uv = coord / min(iResolution.x, iResolution.y);\n        vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n        const float r = 0.5;\n        const float phi = (sqrt(5.0) + 1.0) / 2.0;\n        const float phiSquared = phi * phi;\n        const float rSmaller = r / phiSquared;\n        const float a = r * phi / 2.0;\n        const float h = a - rSmaller;\n        const float w = r * sqrt((sqrt(5.0) + 5.0) / 2.0) / phi;\n        const float phiToThe4th = phiSquared * phiSquared;\n        const float logPhiSquared = log(phiSquared);\n        float t = 1.0 + mod(iTime, phiToThe4th - 1.0);\n        float u = 0.5 * log(t) / logPhiSquared;\n        float z = mix(1.0, 1.0 / phiToThe4th, u);\n        vec2 q = uv * z;\n        float l = length(q);\n        float n = floor(log(r / l) / logPhiSquared);\n        float s = pow(phi, 2.0 * n);\n        q = rotate(q, pi * n - iTime / 8.0);\n        q = mirror(q, 5.0);\n        q = q * s;\n        q = translate(q, vec2(0.0, -rSmaller));\n        float d = sdTriangleIsosceles(vec2(w / 2.0, -h), q) / (s * z);\n        float b = length(uv);\n        col = draw(vec3(0.0), d, 8.0 * b, 4.0 * sqrt(b) * col);\n        fragColor = vec4(col, 1.0);\n    }\n    else\n    {\n        vec2 coord = fragCoord - iResolution.xy / 2.0;\n        vec2 uv = coord / min(iResolution.x, iResolution.y);\n        vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n        const float r = 0.5;\n        const float phi = (sqrt(5.0) + 1.0) / 2.0;\n        const float phiSquared = phi * phi;\n        const float rSmaller = r / phiSquared;\n        const float a = r * phi / 2.0;\n        const float h = a - rSmaller;\n        const float w = r * sqrt((sqrt(5.0) + 5.0) / 2.0) / phi;\n        const float phiToThe4th = phiSquared * phiSquared;\n        const float logPhiSquared = log(phiSquared);\n        float t = 1.0 + mod(iTime, phiToThe4th - 1.0);\n        float u = 0.5 * log(t) / logPhiSquared;\n        float z = mix(1.0, 1.0 / phiToThe4th, u);\n        vec2 q = uv * z;\n        float l = length(q);\n        float n = floor(log(r / l) / logPhiSquared);\n        float s = pow(phi, 2.0 * n);\n        q = rotate(q, pi * n - iTime / 8.0);\n        q = mirror(q, 5.0);\n        q = q * s;\n        q = translate(q, vec2(0.0, -rSmaller));\n        float d = sdTriangleIsosceles(vec2(w / 2.0, -h), q) / (s * z);\n        float b = length(uv);\n        col = draw(vec3(0.0), d, 8.0 * b, 4.0 * sqrt(b) * col);\n        fragColor = vec4(col, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/// Inigo Quilez's signed distance to a 2D triangle\n// reference Demo: https://www.shadertoy.com/view/MldcD7\n\nconst float pi = 3.1415926535897932384626433832795;\n\nfloat sdTriangleIsosceles(in vec2 q, in vec2 p)\n{\n    p.x = abs(p.x * pi);\n    \n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    \n    float s = -sign(q.y);\n\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                  vec2(dot(b, b), s * (p.y - q.y)));\n\n    return (d.x / d.y);\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"DdKBDd","date":"1699069662","viewed":200,"name":"Dark Matter II","username":"ElSolem","description":"https://www.shadertoy.com/view/7ltyDN","likes":0,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Adopted from https://www.shadertoy.com/view/tsXBzS Fractal Pyramid, by bradjamesgrant\n\nvec3 palette(float d){\n    float mx = iMouse.x/iResolution.x;\n    float my = iMouse.y/iResolution.y;\n\treturn mix(vec3(mx,my,0.9),vec3(1.,0.,1.),d); //color of the stars\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a)*0.9;\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<8; ++i){\n        float t = float(iFrame)*0.002;\n        p.yz =rotate(p.yz,t);//rotation speed\n        p.xz =rotate(p.xz,t*1.6); //Rotation speed\n        p.xz = abs(p.xz);\n        p.xz-=.3; //Size???\n\t}\n\treturn dot(sign(p),p)/5.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<64.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*2.5;\n        if(d<0.02){\n            break;\n        }\n        if(d>100.){\n        \tbreak;\n        }\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*0.03)/(3000.*(d));//v1: pink, v2:brightness\n        t+=d;\n    }\n    return vec4(col,60./(d*10.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(41.,41.,-0.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(55,3.,57.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n    }\n    else\n    {\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(0.,0.,-50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"DdtcDf","date":"0","viewed":0,"name":"ElSol First Shader","username":"ElSolem","description":"gradient","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy;\n    xy.x = xy.x / iResolution.x;\n    xy.y = xy.y / iResolution.y;\n    vec4 solidRed = vec4(0.4,0.1,0.98,1.0);\n        solidRed.r = xy.x;\n    fragColor = solidRed;\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"mlcyWS","date":"0","viewed":0,"name":"Fork Daily Shad ElSolem 792","username":"ElSolem","description":"Noise test","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.2, 0.05, smoothstep(0.1,0.75,0.5+0.5*sin(length(uv)+iTime*3.5)));\n\n    col *= col;\n    \n    \n    if (length(col)>=1.0)\n    {\n    col *= 0.;\n    col.x = sin(iTime*uv.x*10001000.);\n    col.y = sin(iTime*uv.y*10100110.);\n    col.z = sin(iTime*uv.y*11110000.);\n    }\n    if (length(col)>=1.15)\n    {\n    col *= 0.;\n    col.x = sin(iTime*uv.y*11001101.);\n    col.y = sin(iTime*uv.x*11111110.);\n    col.z = sin(iTime*uv.x*11110101.);\n    }\n    if (length(col)>=1.4)\n    {\n    col.x = 1.0;\n    col = col.xxx;\n    }\n    \n    \n    col.z = sin(length(uv)*500.5 + iTime*3.14);\n    col *= smoothstep(1.3,0.7,length(uv));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"dtdcR7","date":"1699027359","viewed":60,"name":"Fork Fork Paral ElSolem 909","username":"ElSolem","description":"It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though. [url]https://cineshader.com/view/wtdSR8[/url]\n\nAdding xy = x/y just to see what it does","likes":0,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define TAU PI * 2.\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n// IQ\nfloat tri( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat rep(inout vec2 p, float rep) \n{\n\n    float an = TAU/rep;\n    \n    float fa = (atan(p.y,p.x)+an*0.5)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    \n    p *= rot(sym);\n\n    return ia;\n}\n\n\nfloat tex( vec2 u ){\n    \n    u.y -= 1. / 3.;\n    \n    vec2 u2 = u;\n    float p = 1.;\n    // fpos\n    for( float i = 0.; i < 3.; i++ ){\n        u2.y += sqrt( 3. ) * .1;\n        u2.x = abs( u2.x ) - .1;\n        p = min(\n            p,\n            tri( u2, .1 )\n        );\n    }\n    \n    p = min(\n        p,\n        tri( u, .1 )\n    );\n    \n    return p;\n}\n\nfloat TFace( vec3 p ){\n    /*\n    // tri geo\n    float py = clamp( -p.y, 0., 1. );\n    py = abs( py ) - .01;\n    \n    return max(\n        tri( p.xz, 1. * py ),\n        abs( p.y ) - .2\n    );\n    \n    */ \n    \n    // faces\n    \n    return max(\n        tri( p.xy, .21 ),\n        abs( p.z ) - .001\n    );\n}\n\nfloat map( vec3 p ){\n\n    \n    \n    return TFace( p );\n}\n\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.4; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) > abs(threshold))\n    {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // use different camera setting for CineShader\n    #ifdef IS_CINESHADER\n    \n    // use the relative position of the camera to the center of the screen as ray origin\n\tvec3 rayOri = iCamPos;\n    \n    // screen size is 6m x 6m, or you can use iScreenSize.xy(CineShader only) to get the screen size\n\tvec3 rayDir = normalize(vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 1.0, 0.0) - iCamPos);\n    \n    // make the maxDepth further\n    float maxDepth = 30.0;\n    #else\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 1.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n    float maxDepth = 6.0;\n    #endif\n\t\n\tfloat depth = 0.0, dist;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n        \n        p.x = abs( p.x ) - .25,\n        p.xz *= rot( iTime ),\n        rep( p.xz , 3. ),\n        p.x -= .105,\n        p.y += .1,\n        p.xz *= rot( PI * .5 ),\n        p.yz *= rot( PI * .11 ),\n        p.y -= .1;\n        \n\t\tdist = map(p);\n        \n        \n        depth += dist;\n\t\tif (abs(xy) > abs(threshold)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(maxDepth, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    \n        \n    if(abs(xy) > abs(threshold)){\n        col -= vec3( step( tex( p.xy * 2. ), 0. ) * max( -calcNormal( p ).z, 0. ) ) * .2;\n    }\n    \n    col *= exp( -depth / maxDepth );\n\t\n    #ifdef IS_CINESHADER\n    // set the screen thickness to zero in CineShader\n    fragColor = vec4(col, 0.0);\n    #else\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n    #endif\n    }\n    else\n    {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // use different camera setting for CineShader\n    #ifdef IS_CINESHADER\n    \n    // use the relative position of the camera to the center of the screen as ray origin\n\tvec3 rayOri = iCamPos;\n    \n    // screen size is 6m x 6m, or you can use iScreenSize.xy(CineShader only) to get the screen size\n\tvec3 rayDir = normalize(vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 1.0, 0.0) - iCamPos);\n    \n    // make the maxDepth further\n    float maxDepth = 30.0;\n    #else\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 1.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n    float maxDepth = 6.0;\n    #endif\n\t\n\tfloat depth = 0.0, dist;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n        \n        p.x = abs( p.x ) - .25,\n        p.xz *= rot( iTime ),\n        rep( p.xz , 3. ),\n        p.x -= .105,\n        p.y += .1,\n        p.xz *= rot( PI * .5 ),\n        p.yz *= rot( PI * .11 ),\n        p.y -= .1;\n        \n\t\tdist = map(p);\n        \n        \n        depth += dist;\n\t\tif (abs(xy) > abs(threshold)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(maxDepth, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    \n        \n    if(abs(xy) > abs(threshold)){\n        col -= vec3( step( tex( p.xy * 2. ), 0. ) * max( -calcNormal( p ).z, 0. ) ) * .2;\n    }\n    \n    col *= exp( -depth / maxDepth );\n\t\n    #ifdef IS_CINESHADER\n    // set the screen thickness to zero in CineShader\n    fragColor = vec4(col, 0.0);\n    #else\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n    #endif\n    }\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Parallax view on Cineshader\",\n\t\"description\": \"It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though.\",\n\t\"model\": \"person\"\n}\n*/","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"mlcBRs","date":"1701467857","viewed":19,"name":"Fork blue sand ElSolem 804","username":"ElSolem","description":"blue sand waves test\n","likes":0,"published":0,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn_pixel = fragCoord*0.9;\n\n    vec2 o_trn_nor = o_trn_pixel/iResolution.xy;\n    vec2 o_trn_nor_mouse = iMouse.xy/iResolution.xy;\n\n    vec4 o_col_last = texelFetch(iChannel0, ivec2(o_trn_pixel.xy), 0);\n    \n    \n    fragColor = \n        vec4(o_col_last.x*o_col_last.y*0.3,o_col_last.z*.3,o_col_last.x*1.1, 1.);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float f_n_rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_rnd = f_n_rand(fragCoord+iTime*0.2);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trn_pixel = fragCoord*(1.+n_rnd*0.003);\n    vec2 o_trn_nor = o_trn_pixel/iResolution.xy;\n    vec2 o_trn_nor_mouse = iMouse.xy/iResolution.xy;\n    float n_t = iTime *2.;\n    if(iMouse.z > 0. == false){\n        o_trn_nor_mouse = vec2(sin(n_t), cos(n_t))*0.2+0.4;\n    }\n    ivec2 o_scl_krn = ivec2(3,3);\n    vec4 o_col_last_sum = vec4(0.);\n    \n    vec4 o_col_last = texelFetch(iChannel0, ivec2(o_trn_pixel.xy), 0);\n    \n    for(int n_x = 0; n_x < o_scl_krn.x; n_x+=1){\n        for(int n_y = 0; n_y < o_scl_krn.x; n_y+=1){\n            ivec2 o_trn = ivec2(o_trn_pixel.xy)+ivec2(n_x, n_y)-ivec2(o_scl_krn/2);\n            vec4 o_col_last = texelFetch(iChannel0, o_trn, 0);\n            o_col_last_sum+=o_col_last;\n        }\n    }\n    \n\n    float n_dist = length(o_trn_nor_mouse.xy-o_trn_nor.xy);\n    vec4 o_col_last_sum_nor = o_col_last_sum / vec4(o_scl_krn.x * o_scl_krn.y);\n\n    if(sin(o_col_last_sum_nor.x) * sin(o_col_last_sum_nor.y) == sin(o_col_last_sum_nor.x/o_col_last_sum_nor.y)){\n        fragColor = o_col_last - 0.01;\n    }\n    if(sin(o_col_last_sum_nor.x) * sin(o_col_last_sum_nor.y) >= sin(o_col_last_sum_nor.x/o_col_last_sum_nor.y)){\n        fragColor = o_col_last + 0.001;\n    }\n    if(sin(o_col_last_sum_nor.x) * sin(o_col_last_sum_nor.y) <= sin(o_col_last_sum_nor.x/o_col_last_sum_nor.y)){\n        fragColor = vec4(f_n_rand(o_trn_pixel+iTime*.134)*0.2);\n    }\n    \n    if(sin(o_col_last_sum_nor.x) * sin(o_col_last_sum_nor.y) == sin(o_col_last_sum_nor.x/o_col_last_sum_nor.y)){\n        fragColor = vec4(\n            f_n_rand(o_trn_pixel+iTime*0.1)\n        );\n    }\n\n    \n    \n}\n\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"t32GzK","date":"1744299371","viewed":5,"name":"Fork: Gaussian Depth Sort","username":"ElSolem","description":"This was forked in order to test out ChatGPTs ability to incorporate quantum equalities like XY = X/Y into shaders. The original was chosen for its experimental qualities so  all credits to them. ","likes":0,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPLAT_COUNT 64.0\n#define LAYERS 10.0\n\nvec4 renderSplats(vec2 fragCoord, vec2 resolution, float time) {\n    vec4 color = vec4(0.0);\n    vec3 glow = vec3(0.0);\n    vec2 uv = fragCoord / resolution;\n\n    for (float i = 0.0; i < SPLAT_COUNT; i++) {\n        float t = i / SPLAT_COUNT;\n\n        // Core splat properties\n        vec2 pos = (vec2(cos(t*12.0 + time), sin(t*15.0 + time)) * 0.4 + 0.5) * resolution;\n        float radius = 18.0 + 12.0 * sin(t * 10.0 + time);\n        float radius2 = radius * radius;\n        vec3 baseColor = 0.65 + 0.35 * cos(vec3(t*4.0, t*4.0 + 2.0, t*4.0 + 4.0) + time);\n        float alpha = 0.4;\n        float depth = 0.5 + 0.4 * sin(t * 6.0 + time);\n\n        vec2 delta = fragCoord - pos;\n        float dist2 = dot(delta, delta);\n        float softness = smoothstep(radius2, 0.0, dist2);\n\n        // Main splat blend\n        float falloff = exp(-4.0 * dist2 / radius2);\n        color.rgb += baseColor * alpha * falloff;\n        color.a = min(1.0, color.a + alpha * falloff);\n\n        // Volumetric Bloom: additive radial rings\n        glow.r += baseColor.r * exp(-2.0 * dist2 / (radius2 * 0.8));\n        glow.g += baseColor.g * exp(-2.5 * dist2 / (radius2));\n        glow.b += baseColor.b * exp(-3.0 * dist2 / (radius2 * 1.2));\n\n        // Depth haze layer\n        color.rgb += baseColor * (0.03 * (1.0 - depth)) * softness;\n    }\n\n    // Final bloom tone\n    vec3 finalColor = color.rgb + glow * 0.2;\n    finalColor = pow(finalColor, vec3(0.92)); // subtle gamma for glow pop\n\n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = renderSplats(fragCoord, iResolution.xy, iTime);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wX2GzK","date":"0","viewed":0,"name":"Gaussian Depth Sort Bloom","username":"ElSolem","description":"A forked and optimized copy","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPLAT_COUNT 64.0\n#define LAYERS 10.0\n\nvec4 renderSplats(vec2 fragCoord, vec2 resolution, float time) {\n    vec4 color = vec4(0.0);\n    vec3 glow = vec3(0.0);\n    vec2 uv = fragCoord / resolution;\n\n    for (float i = 0.0; i < SPLAT_COUNT; i++) {\n        float t = i / SPLAT_COUNT;\n\n        // Core splat properties\n        vec2 pos = (vec2(cos(t*12.0 + time), sin(t*15.0 + time)) * 0.4 + 0.5) * resolution;\n        float radius = 18.0 + 12.0 * sin(t * 10.0 + time);\n        float radius2 = radius * radius;\n        vec3 baseColor = 0.65 + 0.35 * cos(vec3(t*4.0, t*4.0 + 2.0, t*4.0 + 4.0) + time);\n        float alpha = 0.4;\n        float depth = 0.5 + 0.4 * sin(t * 6.0 + time);\n\n        vec2 delta = fragCoord - pos;\n        float dist2 = dot(delta, delta);\n        float softness = smoothstep(radius2, 0.0, dist2);\n\n        // Main splat blend\n        float falloff = exp(-4.0 * dist2 / radius2);\n        color.rgb += baseColor * alpha * falloff;\n        color.a = min(1.0, color.a + alpha * falloff);\n\n        // Volumetric Bloom: additive radial rings\n        glow.r += baseColor.r * exp(-2.0 * dist2 / (radius2 * 0.8));\n        glow.g += baseColor.g * exp(-2.5 * dist2 / (radius2));\n        glow.b += baseColor.b * exp(-3.0 * dist2 / (radius2 * 1.2));\n\n        // Depth haze layer\n        color.rgb += baseColor * (0.03 * (1.0 - depth)) * softness;\n    }\n\n    // Final bloom tone\n    vec3 finalColor = color.rgb + glow * 0.2;\n    finalColor = pow(finalColor, vec3(0.92)); // subtle gamma for glow pop\n\n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = renderSplats(fragCoord, iResolution.xy, iTime);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"msVfWV","date":"1698715374","viewed":73,"name":"Into the TV","username":"ElSolem","description":"Hash thingy","likes":3,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*************************************************************************************************\n * Mark Jarzynski and Marc Olano, Hash Functions for GPU Rendering, \n * Journal of Computer Graphics Techniques (JCGT), vol. 9, no. 3, 21-38, 2020\n * Available online http://jcgt.org/published/0009/03/02/\n * \n * Each block visualized 1 bit of hash from bit 0 in the lower left to bit 31 in the upper right.\n * Some hashes do not generate data in all bits, the bits without data are black.\n * \n * For each one dimensional hash there are 2 examples, linear and nested, both have 2-dimensional\n * inputs (UV coords) and only a single output. For the three and four dimensional hashes we\n * combine x and y in different ways for z and w, though in 3D space you would ideally use z as \n * the third input. Constants are sometimes acceptable depending on the hash. For multi-byte\n * hashes only the two dimensional input varation is used an example here. The source code for\n * all of the variations can be found in the Common tab as well as in the full paper.\n * \n * Comment out the return statements in the hash() function to change the hash.\n * Comment out the #defines for BITPLANE and GRID to visualize the hash itself.\n * Comment out the #define COLOR to see the hash in grayscale (only uses x in multi-dimentionsal hashes)\n * \n */\n\n#define BITPLANE\t// Visualize the bitplanes\n#define ANIMATE\t\t// Animate the bits\n#define COLOR\t    // Visualize 3D COLOR\n#define GRID\t\t// Display a grid to seperate the bitplanes\n\nuvec3 hash(vec2 s)\n{\t\n    /*\tUncomment the hash you want to visualize.\n\n\t\tNote that most of these examples the hash is only given 2 inputs unless the hash requires more.\n\t\tBut Common includes 1 through 4 input variations of the hash if they exist.\n\n\t\tYou should play around with different seeds/different number of inputs.\n\t\t\n\t\tAvailable hashes:\n\t\n\t\tbbs, city, esgtsa, fast, hashwithoutsine, hybridtaus, \n\t\tign, iqint1, iqint2, iqint3, jkiss32, lcg, md5, murmur3,\n\t\tpcg, pcg2d, pcg3d, pcg3d16, pcg4d, pseudo, ranlim32,\n\t\tsuperfast, tea2, tea3, tea4, tea5, trig, wang,\n\t\txorshift128, xorshift32, xxhash32\n\t*/    \n    \n    uvec4 u = uvec4(s, uint(s.x) ^ uint(s.y), uint(s.x) + uint(s.y)); // Play with different values for 3rd and 4th params. Some hashes are okay with constants, most aren't.\n    \n    //return uvec3(bbs(seed(u.xy)));\n\t//return uvec3(bbs(bbs(u.x) + u.y));\n    //return uvec3(city(u.xy));\n    //return uvec3(esgtsa(seed(u.xy)));\n    //return uvec3(esgtsa(esgtsa(u.x) + u.y));\n    //return uvec3(fast(s) * float(0xffffffffu));\n    //return uvec3(hashwithoutsine32(s) * float(0xffffffffu));\n    //return uvec3(hybridtaus(u));\n    //return uvec3(ign(s) * float(0xffffffffu));\n    //return uvec3(iqint1(seed(u.xy)));\n    //return uvec3(iqint1(iqint1(u.x) + u.y));\n    //return iqint2(u.xyz);\n    //return uvec3(iqint3(u.xy));\n    //return uvec3(jkiss32(u.xy));\n    //return uvec3(lcg(seed(u.xy)));\n    //return uvec3(lcg(lcg(u.x) + u.y));\n    //return md5(u).xyz;\n    //return uvec3(murmur3(u.xy));\n    //return uvec3(pcg(seed(u.xy)));\n    //return uvec3(pcg(pcg(u.x) + u.y));\n    //return uvec3(pcg2d(u.xy), 0u);\n    return pcg3d(u.xyz);\n    //return pcg3d16(u.xyz);\n    //return pcg4d(u).xyz;\n    //return uvec3(pseudo(s) * float(0xffffffffu));\n    //return uvec3(ranlim32(seed(u.xy)));\n    //return uvec3(ranlim32(ranlim32(u.x) + u.y));\n    //return uvec3(superfast(seed(u.xy)));\n    //return uvec3(superfast(superfast(u.x) + u.y));\n    //return uvec3(tea(2, u.xy), 0u);\n    //return uvec3(tea(3, u.xy), 0u);\n    //return uvec3(tea(4, u.xy), 0u);\n    //return uvec3(tea(5, u.xy), 0u);\n    //return uvec3(trig(s) * float(0xffffffffu));\n    //return uvec3(wang(seed(u.xy)));\n    //return uvec3(wang(wang(u.x) + u.y));\n    //return uvec3(xorshift128(u));\n    //return uvec3(xorshift32(seed(u.xy)));\n    //return uvec3(xorshift32(xorshift32(u.x) + u.y));\n    //return uvec3(xxhash32(u.xy)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\n            // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    }\n    else\n    {\n    // Thanks to \"hash: visualising bitplanes\" by hornet https://www.shadertoy.com/view/lt2yDm\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uint bit = uint(8.0 * uv.x) + 8u * uint(4.0 * uv.y);\n\n#ifdef BITPLANE\n    vec2 seed = mod(fragCoord, vec2(iResolution.x/8.0, iResolution.y/4.0));\n#else\n    vec2 seed = fragCoord;\n#endif\n    \n#ifdef ANIMATE\n    seed += 100.0 * iTime;\n#endif\n    \n    uvec3 hash = hash(seed);\n    \n#ifdef BITPLANE\n#ifdef COLOR\n    fragColor = vec4((hash >> bit) & 1u, 1.0);\n#else\n    fragColor = vec4(vec3(float((hash >> bit) & 1u)), 1.0);\n#endif\n#else\n#ifdef COLOR\n    fragColor = vec4(vec3(hash) * (1.0/float(0xffffffffu)), 1.0);\n#else\n    fragColor = vec4(vec3(float(hash) * (1.0/float(0xffffffffu))), 1.0);\n#endif\n#endif\n    \n#ifdef GRID\n    fragColor *= step( 10.0/iResolution.x, 1.0-abs(2.0*fract(8.0*uv.x)-1.0));\n    fragColor *= step( 10.0/iResolution.y, 1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n#endif\n    }\n}\n\n// https://www.shadertoy.com/view/dsVBRd - Set as default cause if you aren't careful it can turn into flash\n\n// Needed to test this further so used the shader from this link\n// and this one\n// https://www.shadertoy.com/view/Mdt3Df\n\n// You can put any? into the if-else blocks. If you change the origin from 0 to any number the view because bigger/wider\n\n// https://www.shadertoy.com/view/dsyBDy - double mod by Xor","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// commonly used constants\n#define c1 0xcc9e2d51u\n#define c2 0x1b873593u\n\n// Helper Functions\nuint rotl(uint x, uint r)\n{\n\treturn (x << r) | (x >> (32u - r));\n}\n\nuint rotr(uint x, uint r)\n{\n\treturn (x >> r) | (x << (32u - r));\n}\n\nuint fmix(uint h)\n{\n    h ^= h >> 16;\n    h *= 0x85ebca6bu;\n    h ^= h >> 13;\n    h *= 0xc2b2ae35u;\n    h ^= h >> 16;\n    return h;\n}\n\nuint mur(uint a, uint h) {\n    // Helper from Murmur3 for combining two 32-bit values.\n    a *= c1;\n    a = rotr(a, 17u);\n    a *= c2;\n    h ^= a;\n    h = rotr(h, 19u);\n    return h * 5u + 0xe6546b64u;\n}\n\nuint bswap32(uint x) {\n    return (((x & 0x000000ffu) << 24) |\n            ((x & 0x0000ff00u) <<  8) |\n            ((x & 0x00ff0000u) >>  8) |\n            ((x & 0xff000000u) >> 24));\n}\n\nuint taus(uint z, int s1, int s2, int s3, uint m)\n{\n\tuint b = (((z << s1) ^ z) >> s2);\n    return (((z & m) << s3) ^ b);\n}\n\n\n\n// convert 2D seed to 1D\n// 2 imad\nuint seed(uvec2 p) {\n    return 19u * p.x + 47u * p.y + 101u;\n}\n\n// convert 3D seed to 1D\nuint seed(uvec3 p) {\n    return 19u * p.x + 47u * p.y + 101u * p.z + 131u;\n}\n\n// convert 4D seed to 1D\nuint seed(uvec4 p) {\n\treturn 19u * p.x + 47u * p.y + 101u * p.z + 131u * p.w + 173u;\n}\n\n\n\n\n/**********************************************************************\n * Hashes\n **********************************************************************/\n\n// BBS-inspired hash\n//  - Olano, Modified Noise for Evaluation on Graphics Hardware, GH 2005\nuint bbs(uint v) {\n    v = v % 65521u;\n    v = (v * v) % 65521u;\n    v = (v * v) % 65521u;\n    return v;\n}\n\n\n\n// CityHash32, adapted from Hash32Len0to4 in https://github.com/google/cityhash\nuint city(uint s)\n{\n    uint len = 4u;\n\tuint b = 0u;\n    uint c = 9u;\n\n    for (uint i = 0u; i < len; i++) {\n    \tuint v = (s >> (i * 8u)) & 0xffu;\n        b = b * c1 + v;\n        c ^= b;\n    }\n\n    return fmix(mur(b, mur(len, c)));\n}\n\n// CityHash32, adapted from Hash32Len5to12 in https://github.com/google/cityhash\nuint city(uvec2 s)\n{\n    uint len = 8u;\n    uint a = len, b = len * 5u, c = 9u, d = b;\n\n    a += bswap32(s.x);\n    b += bswap32(s.y);\n    c += bswap32(s.y);\n\n    return fmix(mur(c, mur(b, mur(a, d))));\n}\n\n// CityHash32, adapted from Hash32Len5to12 in https://github.com/google/cityhash\nuint city(uvec3 s)\n{\n    uint len = 12u;\n    uint a = len, b = len * 5u, c = 9u, d = b;\n\n    a += bswap32(s.x);\n    b += bswap32(s.z);\n    c += bswap32(s.y);\n\n    return fmix(mur(c, mur(b, mur(a, d))));\n}\n\n// CityHash32, adapted from Hash32Len12to24 in https://github.com/google/cityhash\nuint city(uvec4 s)\n{\n    uint len = 16u;\n    uint a = bswap32(s.w);\n    uint b = bswap32(s.y);\n    uint c = bswap32(s.z);\n    uint d = bswap32(s.z);\n    uint e = bswap32(s.x);\n    uint f = bswap32(s.w);\n    uint h = len;\n\n    return fmix(mur(f, mur(e, mur(d, mur(c, mur(b, mur(a, h)))))));\n}\n\n\n\n// Schechter and Bridson hash \n// https://www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\nuint esgtsa(uint s)\n{\n    s = (s ^ 2747636419u) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    return s;\n}\n\n\n\n// UE4's RandFast function\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush\nfloat fast(vec2 v)\n{\n    v = (1./4320.) * v + vec2(0.25,0.);\n    float state = fract( dot( v * v, vec2(3571)));\n    return fract( state * state * (3571. * 2.));\n}\n\n\n\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hashwithoutsine12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hashwithoutsine13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hashwithoutsine21(float p)\n{\n\tvec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hashwithoutsine22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hashwithoutsine23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hashwithoutsine31(float p)\n{\n   vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashwithoutsine32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashwithoutsine33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hashwithoutsine41(float p)\n{\n\tvec4 p4 = fract(vec4(p,p,p,p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hashwithoutsine42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hashwithoutsine43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hashwithoutsine44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// Hybrid Taus\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch37.html\nuint hybridtaus(uvec4 z)\n{\n    z.x = taus(z.x, 13, 19, 12, 0xfffffffeu);\n    z.y = taus(z.y, 2, 25, 4, 0xfffffff8u);\n    z.z = taus(z.z, 3, 11, 17, 0xfffffff0u);\n    z.w = z.w * 1664525u + 1013904223u;\n\n    return z.x ^ z.y ^ z.z ^ z.w;\n}\n\n// Interleaved Gradient Noise\n//  - Jimenez, Next Generation Post Processing in Call of Duty: Advanced Warfare\n//    Advances in Real-time Rendering, SIGGRAPH 2014\nfloat ign(vec2 v)\n{\n    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(v, magic.xy)));\n}\n\n\n\n// Integer Hash - I\n// - Inigo Quilez, Integer Hash - I, 2017\n//   https://www.shadertoy.com/view/llGSzw\nuint iqint1(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n\n    return n;\n}\n\n// Integer Hash - II\n// - Inigo Quilez, Integer Hash - II, 2017\n//   https://www.shadertoy.com/view/XlXcW4\nuvec3 iqint2(uvec3 x)\n{\n    const uint k = 1103515245u;\n\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n\n    return x;\n}\n\n// Integer Hash - III\n// - Inigo Quilez, Integer Hash - III, 2017\n//   https://www.shadertoy.com/view/4tXyWN\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n\n    return n;\n}\n\n\n\nuint jkiss32(uvec2 p)\n{\n    uint x=p.x;//123456789;\n    uint y=p.y;//234567891;\n\n    uint z=345678912u,w=456789123u,c=0u;\n    int t;\n    y ^= (y<<5); y ^= (y>>7); y ^= (y<<22);\n    t = int(z+w+c); z = w; c = uint(t < 0); w = uint(t&2147483647);\n    x += 1411392427u;\n    return x + y + w;\n}\n\n\n\n// linear congruential generator\nuint lcg(uint p)\n{\n    return p * 1664525u + 1013904223u;\n}\n\n\n\n// MD5GPU\n// https://www.microsoft.com/en-us/research/wp-content/uploads/2007/10/tr-2007-141.pdf\n#define A0 0x67452301u\n#define B0 0xefcdab89u\n#define C0 0x98badcfeu\n#define D0 0x10325476u\n\nuint F(uvec3 v) { return (v.x & v.y) | (~v.x & v.z); }\nuint G(uvec3 v) { return (v.x & v.z) | (v.y & ~v.z); }\nuint H(uvec3 v) { return v.x ^ v.y ^ v.z; }\nuint I(uvec3 v) { return v.y ^ (v.x | ~v.z); }\n\nvoid FF(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + F(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nvoid GG(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + G(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nvoid HH(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + H(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nvoid II(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + I(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nuint K(uint i)\n{\n    return uint(abs(sin(float(i)+1.)) * float(0xffffffffu));\n}\n\nuvec4 md5(uvec4 u)\n{\n    uvec4 digest = uvec4(A0, B0, C0, D0);\n    uvec4 r, v = digest;\n    uint i = 0u;\n\n\tuint M[16];\n\tM[0] = u.x; M[1] = u.y;\tM[2] = u.z;\tM[3] = u.w;\n\tM[4] = 0u; M[5] = 0u; M[6] = 0u; M[7] = 0u; M[8] = 0u;\n\tM[9] = 0u; M[10] = 0u; M[11] = 0u; M[12] = 0u; M[13] = 0u;\n\tM[14] = 0u; M[15] = 0u;\n\n    r = uvec4(7, 12, 17, 22);\n    FF(v, r, M[0], K(i++));\n    FF(v, r, M[1], K(i++));\n    FF(v, r, M[2], K(i++));\n    FF(v, r, M[3], K(i++));\n    FF(v, r, M[4], K(i++));\n    FF(v, r, M[5], K(i++));\n    FF(v, r, M[6], K(i++));\n    FF(v, r, M[7], K(i++));\n    FF(v, r, M[8], K(i++));\n    FF(v, r, M[9], K(i++));\n    FF(v, r, M[10], K(i++));\n    FF(v, r, M[11], K(i++));\n    FF(v, r, M[12], K(i++));\n    FF(v, r, M[13], K(i++));\n    FF(v, r, M[14], K(i++));\n    FF(v, r, M[15], K(i++));\n\n    r = uvec4(5, 9, 14, 20);\n    GG(v, r, M[1], K(i++));\n    GG(v, r, M[6], K(i++));\n    GG(v, r, M[11], K(i++));\n    GG(v, r, M[0], K(i++));\n    GG(v, r, M[5], K(i++));\n    GG(v, r, M[10], K(i++));\n    GG(v, r, M[15], K(i++));\n    GG(v, r, M[4], K(i++));\n    GG(v, r, M[9], K(i++));\n    GG(v, r, M[14], K(i++));\n    GG(v, r, M[3], K(i++));\n    GG(v, r, M[8], K(i++));\n    GG(v, r, M[13], K(i++));\n    GG(v, r, M[2], K(i++));\n    GG(v, r, M[7], K(i++));\n    GG(v, r, M[12], K(i++));\n\n    r = uvec4(4, 11, 16, 23);\n    HH(v, r, M[5], K(i++));\n    HH(v, r, M[8], K(i++));\n    HH(v, r, M[11], K(i++));\n    HH(v, r, M[14], K(i++));\n    HH(v, r, M[1], K(i++));\n    HH(v, r, M[4], K(i++));\n    HH(v, r, M[7], K(i++));\n    HH(v, r, M[10], K(i++));\n    HH(v, r, M[13], K(i++));\n    HH(v, r, M[0], K(i++));\n    HH(v, r, M[3], K(i++));\n    HH(v, r, M[6], K(i++));\n    HH(v, r, M[9], K(i++));\n    HH(v, r, M[12], K(i++));\n    HH(v, r, M[15], K(i++));\n    HH(v, r, M[2], K(i++));\n\n    r = uvec4(6, 10, 15, 21);\n    II(v, r, M[0], K(i++));\n    II(v, r, M[7], K(i++));\n    II(v, r, M[14], K(i++));\n    II(v, r, M[5], K(i++));\n    II(v, r, M[12], K(i++));\n    II(v, r, M[3], K(i++));\n    II(v, r, M[10], K(i++));\n    II(v, r, M[1], K(i++));\n    II(v, r, M[8], K(i++));\n    II(v, r, M[15], K(i++));\n    II(v, r, M[6], K(i++));\n    II(v, r, M[13], K(i++));\n    II(v, r, M[4], K(i++));\n    II(v, r, M[11], K(i++));\n    II(v, r, M[2], K(i++));\n    II(v, r, M[9], K(i++));\n\n    return digest + v;\n}\n\n\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uint seed)\n{\n    uint h = 0u;\n    uint k = seed;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 4u;\n\n    return fmix(h);\n}\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uvec2 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 8u;\n\n    return fmix(h);\n}\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uvec3 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.z;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 12u;\n\n    return fmix(h);\n}\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uvec4 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.z;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.w;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 16u;\n\n    return fmix(h);\n}\n\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\n\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d16(uvec3 v)\n{\n    v = v * 12829u + 47989u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n\tv >>= 16u;\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    return v;\n}\n\n\n\n// UE4's PseudoRandom function\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush\nfloat pseudo(vec2 v) {\n    v = fract(v/128.)*128. + vec2(-64.340622, -72.465622);\n    return fract(dot(v.xyx * v.xyy, vec3(20.390625, 60.703125, 2.4281209)));\n}\n\n\n\n// Numerical Recipies 3rd Edition\nuint ranlim32(uint j){\n    uint u, v, w1, w2, x, y;\n\n    v = 2244614371U;\n    w1 = 521288629U;\n    w2 = 362436069U;\n\n    u = j ^ v;\n\n    u = u * 2891336453U + 1640531513U;\n    v ^= v >> 13; v ^= v << 17; v ^= v >> 5;\n    w1 = 33378u * (w1 & 0xffffu) + (w1 >> 16);\n    w2 = 57225u * (w2 & 0xffffu) + (w2 >> 16);\n\n    v = u;\n\n    u = u * 2891336453U + 1640531513U;\n    v ^= v >> 13; v ^= v << 17; v ^= v >> 5;\n    w1 = 33378u * (w1 & 0xffffu) + (w1 >> 16);\n    w2 = 57225u * (w2 & 0xffffu) + (w2 >> 16);\n\n    x = u ^ (u << 9); x ^= x >> 17; x ^= x << 6;\n    y = w1 ^ (w1 << 17); y ^= y >> 15; y ^= y << 5;\n\n    return (x + v) ^ (y + w2);\n}\n\n\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uint data)\n{\n\tuint hash = 4u, tmp;\n\n    hash += data & 0xffffu;\n    tmp = (((data >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec2 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec3 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.z & 0xffffu;\n    tmp = (((data.z >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec4 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.z & 0xffffu;\n    tmp = (((data.z >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.w & 0xffffu;\n    tmp = (((data.w >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n\n\n// Tiny Encryption Algorithm\n//  - Zafar et al., GPU random numbers via the tiny encryption algorithm, HPG 2010\nuvec2 tea(int tea, uvec2 p) {\n    uint s = 0u;\n\n    for( int i = 0; i < tea; i++) {\n        s += 0x9E3779B9u;\n        p.x += (p.y<<4u)^(p.y+s)^(p.y>>5u);\n        p.y += (p.x<<4u)^(p.x+s)^(p.x>>5u);\n    }\n    return p.xy;\n}\n\n\n\n// common GLSL hash\n//  - Rey, On generating random numbers, with help of y= [(a+x)sin(bx)] mod 1,\n//    22nd European Meeting of Statisticians and the 7th Vilnius Conference on\n//    Probability Theory and Mathematical Statistics, August 1998\n/*\nuvec2 trig(uvec2 p) {\n    return uvec2(float(0xffffff)*fract(43757.5453*sin(dot(vec2(p),vec2(12.9898,78.233)))));\n}\n*/\nfloat trig(vec2 p)\n{\n    return fract(43757.5453*sin(dot(p, vec2(12.9898,78.233))));\n}\n\n\n\n// Wang hash, described on http://burtleburtle.net/bob/hash/integer.html\n// original page by Thomas Wang 404\nuint wang(uint v)\n{\n    v = (v ^ 61u) ^ (v >> 16u);\n    v *= 9u;\n    v ^= v >> 4u;\n    v *= 0x27d4eb2du;\n    v ^= v >> 15u;\n    return v;\n}\n\n\n\n// 128-bit xorshift\n//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003\nuint xorshift128(uvec4 v)\n{\n    v.w ^= v.w << 11u;\n    v.w ^= v.w >> 8u;\n    v = v.wxyz;\n    v.x ^= v.y;\n    v.x ^= v.y >> 19u;\n    return v.x;\n}\n\n\n\n// 32-bit xorshift\n//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003\nuint xorshift32(uint v)\n{\n    v ^= v << 13u;\n    v ^= v >> 17u;\n    v ^= v << 5u;\n    return v;\n}\n\n\n\n// xxhash (https://github.com/Cyan4973/xxHash)\n//   From https://www.shadertoy.com/view/Xt3cDn\nuint xxhash32(uint p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 = p + PRIME32_5;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint xxhash32(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint xxhash32(uvec3 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 =  p.z + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.y * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint xxhash32(uvec4 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 =  p.w + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.y * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.z * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"DsKBDd","date":"0","viewed":0,"name":"Locks and Chambers","username":"ElSolem","description":"https://www.shadertoy.com/view/wd3BWN\n\nhttps://www.shadertoy.com/view/NtlBWj","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//change AA depending on specs\n#define AA 2.\n#define segments 15.0\n#define PI 3.14159\n#define TAU PI*2.0\n#define ZERO min(iFrame,0)\n#define boxScale .9\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\n\nfloat opRepLim( in float p, in float c, in float l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec2 rot(vec2 p,float a){\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(s,c,-c,s);\n}\nfloat sdRingBox( vec3 p, vec3 b)\n{\n  p*=1.4;\n  float angper = TAU/segments;\n  vec2 origin = vec2(0.0,.7);\n  float angle = iTime+atan(p.y,p.x)*2.;\n  vec3 pivotSpot = normalize(vec3(p.x,p.y,0.))*origin.y;\n  \n  \n  float r = length(p.xy)-origin.y;\n  vec2 twistCoords = vec2(r,p.z);\n  vec2 new = rot(twistCoords,(iTime+angle)/(2.));\n  r = new.x; p.z = new.y;\n  p.z = opRepLim(p.z,.13*((1.1+.6*max(0.0,sin(iTime)))*boxScale),1.);\n  r = opRepLim(r,.11*((1.1+.6*max(0.0,cos(PI/2.+iTime)))*boxScale),1.);\n  \n  //because angle is -x,x, ends up being 2x wide, so we divide by 2.\n  angle = mod(angle+angper,angper)-angper/2.;\n  p.xy = vec2(angle,r);\n  b.x/=boxScale;\n  vec3 q = abs(p) - b;\n  //subtracting at end of sdf creates 'rounded' cubes\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-.01;\n}\n\nfloat map(vec3 p){\n    return sdRingBox(p,boxScale*vec3((TAU/segments)-.22,0.05,.06));\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.001,0.0);\n    return normalize(vec3(map(p+e.xyy), map(p+e.yxy),map(p+e.yyx)));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 rm(vec3 ro, vec3 rd){\n    vec3 p;\n    float t, d, r;\n    for(int i =0; i<1000; i++){\n        p = ro+t*rd;\n        d = map(p);\n        if(d>10.)\n            break;\n        if(d<0.0001){\n            t+=d;\n            p=ro+t*rd;\n            vec3 n =  getNormal(p);\n            float fre = clamp(1.0+dot(n,rd),0.0,1.0);\n            float AO =calcAO(p,n,iTime);\n            return (1.0-pow(fre,2.))*AO*(.5+.5*abs(n.y)*vec3(0.4,0.8,0.9));\n        }\n        t+=d*.6;\n    }\n    float ratio = pow(abs(rd.y/rd.z),3.);\n    return mix(vec3(.0,.0,.0),vec3(.7,.2,.68),ratio);\n\n\n}\n\n\n\n\n\n\n\n\n#define tau 6.2831853\n#define r .27\n#define percentC 1./4.5\n\nvec3 palette(float d){\n    float q =d*40.;\n    q = fract(q+iTime);\n    \n    if(d<0.)\n        return vec3(.1+q*.1);\n    \n    return vec3(q+.4,.4,0.6+d);\n}\nvec3 chamberSDF(vec2 uv){\n\tvec3 col;\n    float angPerSegment = (tau)/segments;    \n    float ang = atan(uv.y,uv.x)+pow(fract(iTime*.3),10.);\n    float ang0PI = (ang+PI);\n    ang0PI*=(segments/(tau));\n    ang0PI = fract(ang0PI);\n    ang0PI*=((tau)/segments);\n    uv = vec2(cos(PI+ang0PI),sin(PI+ang0PI))*length(uv);\n    float ang0SegN = ang0PI/angPerSegment;\n    float angN = ang0PI/(tau);\n    float angSegSigned = (ang0SegN-.5);\n    float angSeguSigned = abs(angSegSigned);\n\n    float hs = (angPerSegment)/2.;\n    float cs = hs+sign(angSegSigned)*(percentC)*angPerSegment;\n    vec2 cPos = vec2(cos(-PI+hs),sin(-PI+hs))*r;\n    vec2 ccornerPos = vec2(cos((-PI)+cs),sin((-PI)+cs))*r;\n    float lr = length(cPos-ccornerPos);\n\n    float dC = length(uv)-r;\n    float dc = -(length(uv-cPos)-lr);\n\n    if(angSeguSigned>percentC) {\n\n        return palette(max(dc,dC));\n        \n    }\n\n    if(dC>0.){\n        dC = length(uv-ccornerPos);   \n        return palette(dC);\n        \n    }\n    return palette(max(dc,dC));\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\n    vec3 col = vec3(0.);\n    for(float m = 0.;m<AA;m++){\n    \tfor(float n = 0.;n<AA;n++){\n    \t\tvec2 uv = (fragCoord+(vec2(m,n)/AA)-(iResolution.xy*.5))/iResolution.x;\n            col+=chamberSDF(uv);\n            \n    \t}\n    }\n    col/=AA*AA;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    }\n    else\n    {\n    vec3 col = vec3(0.,0.,0.);\n    for(float m = 0.;m<AA;m++){\n    \tfor(float n = 0.;n<AA;n++){\n        vec2 uv = (fragCoord+(vec2(m,n)/AA)-(iResolution.xy*.5))/iResolution.x;\n        vec3 ro = vec3(cos(iTime),0.,sin(iTime))*20.;\n        ro = vec3(0.,0.,-1.0);\n        vec3 cf = -normalize(ro);\n        vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = cf+(uv.x*cs + uv.y*cu)*5.5;\n\n        vec3 rd = normalize(uuv-ro);\n        col += rm(ro,rd);\n        }\n     }\n     col/=AA*AA;\n        // Output to screen\n        col = pow(col, vec3(1.0/2.2));\n        fragColor = vec4(col,1.0);\n}\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"43BGzV","date":"0","viewed":0,"name":"Luminous rings","username":"ElSolem","description":"Basic color shift with decreasing rings","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Basic rings\" by None. https://shadertoy.com/view/-1\n// 2024-02-22 15:19:12\n\n// Fork of \"Basic rings\" by ElSolem. https://shadertoy.com/view/43B3RV\n// 2024-02-22 15:04:18\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float d = length(uv);\n    d = sin(d*8. + iTime)/8.;\n    d = abs(d);\n\n    d = .22/d;\n    \n    col *= d;\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"csVfDt","date":"1698847640","viewed":180,"name":"Octagramatron","username":"ElSolem","description":"https://www.shadertoy.com/view/tlVGDt","likes":8,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nfloat gTime = 0.0;\nconst float REPEAT = 5.0;\n\n// \nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat box(vec3 pos, float scale) {\n    pos *= scale;\n    float base = sdBox(pos, vec3(0.4, 0.4, 0.1)) / 1.5;\n    pos.xy *= 5.0;\n    pos.y -= 3.5;\n    pos.xy *= rot(0.75);\n    float result = -base;\n    return result;\n}\n\nfloat box_set(vec3 pos, float iTime) {\n    vec3 pos_origin = pos;\n    pos = pos_origin;\n    pos.y += sin(gTime * 0.4) * 2.5;\n    pos.xy *= rot(0.8);\n    float box1 = box(pos, 2.0 - abs(sin(gTime * 0.4)) * 1.5);\n    pos = pos_origin;\n    pos.y -= sin(gTime * 0.4) * 2.5;\n    pos.xy *= rot(0.8);\n    float box2 = box(pos, 2.0 - abs(sin(gTime * 0.4)) * 1.5);\n    pos = pos_origin;\n    pos.x += sin(gTime * 0.4) * 2.5;\n    pos.xy *= rot(0.8);\n    float box3 = box(pos, 2.0 - abs(sin(gTime * 0.4)) * 1.5);\n    pos = pos_origin;\n    pos.x -= sin(gTime * 0.4) * 2.5;\n    pos.xy *= rot(0.8);\n    float box4 = box(pos, 2.0 - abs(sin(gTime * 0.4)) * 1.5);\n    pos = pos_origin;\n    pos.xy *= rot(0.8);\n    float box5 = box(pos, 0.5) * 6.0;\n    pos = pos_origin;\n    float box6 = box(pos, 0.5) * 6.0;\n    float result = max(max(max(max(max(box1, box2), box3), box4), box5), box6);\n    return result;\n}\n\nfloat map(vec3 pos, float iTime) {\n    vec3 pos_origin = pos;\n    float box_set1 = box_set(pos, iTime);\n    return box_set1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float xy = p.x / p.y;\n    float threshold = 2.0;\n\n    if (abs(xy) < abs(threshold)) {\n        vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        vec3 ro = vec3(0.0, -0.2, iTime * 4.0);\n        vec3 ray = normalize(vec3(p, 1.5));\n        ray.xy = ray.xy * rot(sin(iTime * 0.03) * 5.0);\n        ray.yz = ray.yz * rot(sin(iTime * 0.05) * 0.2);\n        float t = 0.1;\n        vec3 col = vec3(0.0);\n        float ac = 0.0;\n\n        for (int i = 0; i < 99; i++) {\n            vec3 pos = ro + ray * t;\n            pos = mod(pos - 2.0, 4.0) - 2.0;\n            gTime = iTime - float(i) * 0.01;\n\n            float d = map(pos, iTime);\n            d = max(abs(d), 0.01);\n            ac += exp(-d * 23.0);\n            t += d * 0.55;\n        }\n\n        col = vec3(ac * 0.02);\n        col += vec3(0.0, 0.2 * abs(sin(iTime)), 0.5 + sin(iTime) * 0.2);\n        fragColor = vec4(col, 1.0 - t * (0.02 + 0.02 * sin(iTime)));\n    } else {\n        vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        vec3 ro = vec3(0.0, -0.2, iTime * 4.0);\n        vec3 ray = normalize(vec3(p, 1.5));\n        ray.xy = ray.xy * rot(sin(iTime * 0.03) * 5.0);\n        ray.yz = ray.yz * rot(sin(iTime * 0.05) * 0.2);\n        float t = 0.1;\n        vec3 col = vec3(0.0);\n        float ac = 0.0;\n\n        for (int i = 0; i < 99; i++) {\n            vec3 pos = ro + ray * t;\n            pos = mod(pos - 2.0, 4.0) - 2.0;\n            gTime = iTime - float(i) * 0.01;\n\n            float d = map(pos, iTime);\n            d = max(abs(d), 0.01);\n            ac += exp(-d * 23.0);\n            t += d * 0.55;\n        }\n\n        col = vec3(ac * 0.02);\n        col += vec3(0.0, 0.2 * abs(sin(iTime)), 0.5 + sin(iTime) * 0.2);\n        fragColor = vec4(col, 1.0 - t * (0.02 + 0.02 * sin(iTime)));\n    }\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"DsKfDt","date":"1698847631","viewed":124,"name":"PolyParallax Pyramid","username":"ElSolem","description":"https://www.shadertoy.com/view/tsXBzS :: xy = p.x / p.y","likes":4,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float d) {\n    return mix(vec3(0.2, 0.7, 0.9), vec3(1.0, 0.0, 1.0), d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    for (int i = 0; i < 8; ++i) {\n        float t = iTime * 0.2;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 1.89);\n        p.xz = abs(p.xz);\n        p.xz -= 0.5;\n    }\n    return dot(sign(p), p) / 5.0;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i < 64.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 100.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (400.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 100.0));\n}\n\nbool Alakazan(float value1, float value2) {\n    return (value1 == value2) || (value1 != value2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float xy = p.x / p.y;\n    float threshold = 2.0;\n\n    // Alakazan logic\n    bool alakazanResult = Alakazan(xy, threshold);\n\n    if (alakazanResult) {\n        vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n        vec3 ro = vec3(0.0, 0.0, -50.0);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    } else {\n        vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n        vec3 ro = vec3(0.0, 0.0, -50.0);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    }\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"dsVfzd","date":"1698554970","viewed":216,"name":"PolyRefraction Parallax || P=NP","username":"ElSolem","description":"Test of the simple parrallax thingy. It applies the symbol equation for calculating parallax. Biconvex Parallax, and Biconcave Parallax. It calculates the line through an Abs(0) and then plots points around it. It starts at 1 and increases exponentially. ","likes":5,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float d) {\n    return mix(vec3(0.1, 0.94, 0.98), vec3(1., 0., 1.), d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    for (int i = -5; i < 25; ++i) {\n        float t = iTime * -0.314;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 1.50);\n        p.xz = abs(p.xz);\n        p.xz -= 0.12;\n    }\n    return dot(sign(p), p) / 1.;\n}\n\nbool Alakazan(float value1, float value2) {\n    return (value1 == value2) || (value1 != value2);\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 20.;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 3.; i < 270.; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.3;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 30.) {\n            break;\n        }\n        // col += vec3(2.64, 0.8, 0.8) / (400. * (d));\n        col += palette(length(p) * 0.1) / (400. * (d));\n        t += d;\n    }\n    return vec4(col, 1. / (d * 100.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.0;\n\n    // Alakazan logic\n    bool alakazanResult = Alakazan(xy, threshold);\n\n    // Check if xy is within the threshold to plot the point\n    if (alakazanResult) {\n        vec2 uv = (fragCoord - (iResolution.xy / 2.)) / iResolution.x;\n        vec3 ro = vec3(0., 0., 50.);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(0., 8., 0.)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3. + uv.x * cs + uv.y * cu;\n\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    } else {\n        vec2 uv = (fragCoord - (iResolution.xy / 2.)) / iResolution.x;\n        vec3 ro = vec3(0., 0., 50.);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(0., 8., 0.)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3. + uv.x * cs + uv.y * cu;\n\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    }\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wXX3Rl","date":"1743343058","viewed":44,"name":"Polyparallax-One","username":"ElSolem","description":"Rzhiss","likes":0,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    // Compute function values\n    float lhs = sin(cos(uv.x * uv.y));\n    float rhs = cos(sin(uv.x / (uv.y + 1e-6))); // Avoid division by zero\n    \n    // Compute difference (for visualization)\n    float diff = abs(lhs - rhs);\n    \n    // Generate color using time and difference\n    vec3 col = mix(vec3(0.2, 0.3, 0.9), vec3(1.0, 0.2, 0.4), sin(iTime) * 0.5 + 0.5);\n    col *= smoothstep(0.1, 0.01, diff); // Highlight areas where LHS  RHS\n    \n    // Output final color\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"t3f3Rl","date":"1743343126","viewed":53,"name":"Polyparallax-Two","username":"ElSolem","description":"Rzhiss","likes":0,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    // Compute function values\n    float lhs = cos((uv.x * uv.x) * pow(uv.y, -2.0));\n    float rhs = sin((uv.x * uv.x) / (pow(uv.y, -2.0) + 1e-6)); // Avoid division by zero\n\n    // Compute difference (for visualization)\n    float diff = abs(lhs - rhs);\n    \n    // Dynamic coloring based on time and equation behavior\n    vec3 col = mix(vec3(0.0, 0.8, 0.6), vec3(1.0, 0.3, 0.2), cos(iTime) * 0.5 + 0.5);\n    col *= smoothstep(0.1, 0.01, diff); // Highlight where LHS  RHS\n\n    // Output final color\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wXjGzK","date":"0","viewed":0,"name":"QAI Test","username":"ElSolem","description":"Test of ChatGPTs ability to use quantum equaltities like XY = X/Y","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPLAT_COUNT 64.0\n#define LAYERS 10.0\n\nvec4 renderSplats(vec2 fragCoord, vec2 resolution, float time) {\n    vec4 color = vec4(0.0);\n\n    for (float i = 0.0; i < SPLAT_COUNT; i++) {\n        float t = i / SPLAT_COUNT;\n\n        // Position\n        vec2 pos = (vec2(cos(t*12.0 + time), sin(t*15.0 + time)) * 0.4 + 0.5) * resolution;\n\n        // Radius, color, alpha, depth\n        float radius = 20.0 + 15.0 * sin(t * 10.0);\n        float radius2 = radius * radius;\n        vec3 col = 0.5 + 0.5 * cos(vec3(t*3.0, t*3.0 + 2.0, t*3.0 + 4.0) + time);\n        float alpha = 0.3;\n        float depth = 0.5 + 0.4 * sin(t * 5.0 + time);\n\n        // Quantum equality check on layer quantization\n        float qLayer = (depth * LAYERS == depth / LAYERS) ? depth / LAYERS : depth * LAYERS;\n        if (floor(qLayer) != floor(mod(time, LAYERS))) continue;\n\n        // Quantum-style distance\n        vec2 delta = fragCoord - pos;\n        float dist2 = dot(delta, delta);\n        float xyq = delta.x / (delta.y + 1e-5);\n        float qDist = (delta.x * delta.y == xyq) ? xyq * xyq : dist2;\n\n        if (qDist < radius2) {\n            float blend = alpha * exp(-4.0 * qDist / radius2);\n            color.rgb = mix(color.rgb, col, blend);\n            color.a = mix(color.a, 1.0, blend);\n        }\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(renderSplats(fragCoord, iResolution.xy, iTime).rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tXfGRj","date":"1743181861","viewed":47,"name":"Rzhis","username":"ElSolem","description":"Plot of cos(xy)*sin(-1/12)=tan(-1/12(x/y))","likes":0,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; // Maintain aspect ratio\n\n    // Dynamic zoom effect (oscillates between 1.0 and 2.0)\n    float zoom = 1.5 + sin(iTime * 0.5) * 0.5;\n    uv *= zoom;\n\n    // Rotation transformation (rotates like a clock over time)\n    float angle = iTime * 0.2; // Rotation speed\n    mat2 rotation = mat2(cos(angle), -sin(angle),\n                         sin(angle), cos(angle));\n    uv = rotation * uv;\n\n    float x = uv.x * 3.0;\n    float y = uv.y * 3.0;\n    \n    float equation = cos(x * y) * sin(-1.0 / 12.0) - tan((-1.0 / 12.0) * (x / y));\n    \n    // Color shifting over time\n    vec3 color = vec3(0.5 + 0.5 * sin(equation + iTime),\n                      0.5 + 0.5 * cos(equation + iTime),\n                      0.5 + 0.5 * sin(iTime * 0.5));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wXfGzj","date":"0","viewed":0,"name":"Rzhis Eye","username":"ElSolem","description":"Rzhis4","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 O, vec2 F)\n{\n    // Iterator and attenuation (distance-squared)\n    float i = .2, a;\n    \n    // Resolution for scaling and centering\n    vec2 r = iResolution.xy,\n         // Centered ratio-corrected coordinates\n         p = ( F+F - r ) / r.y / .7,\n         // Diagonal vector for skewing\n         d = vec2(-1,1),\n         // Blackhole center\n         b = p - i*d,\n         // Rotate and apply perspective\n         c = p * mat2(1, 1, d/(.1 + i/dot(b,b))),\n         // Rotate into spiraling coordinates\n         v = c * mat2(cos(.5*log(a=dot(c,c)) + iTime*i + vec4(0,33,11,0)))/i,\n         // Waves cumulative total for coloring\n         w;\n    \n    // Loop through waves\n    for(; i++<9.; w += 1.+sin(v) )\n        // Distort coordinates\n        v += .7* sin(v.yx*i+iTime) / i + .5;\n    \n    // Accretion disk radius\n    i = length( sin(v/.3)*.4 + c*(3.+d) );\n    \n    // Apply the equation: sin(XY) * cos(-1/12) = tan(-1/12 * (X/Y))\n    float x = p.x * 3.0;  // Rescale for visibility\n    float y = p.y * 3.0;\n    \n    float leftSide = sin(x * y) * cos(-1.0 / 12.0);  // Left side of the equation\n    float rightSide = tan((-1.0 / 12.0) * (x / y)); // Right side of the equation\n    \n    // Calculate the difference between the left and right sides\n    float diff = abs(leftSide - rightSide);\n\n    // Define a threshold for when the equation is \"true\"\n    bool equationTrue = (diff < 0.01); // Allow a small difference for plotting points\n\n    // Color dynamic change over time\n    vec3 color = vec3(0.0, 0.0, 0.0); // Default to black\n\n    if (equationTrue) {\n        // Color change based on time for the plotted points\n        color = vec3(sin(iTime * 0.3), cos(iTime * 0.2), sin(iTime * 0.1)); // Dynamic color shift\n    }\n\n    // Red/blue gradient for visual effects\n    O = 1. - exp( -exp( c.x * vec4(.6,-.4,-1,0) )\n                   // Wave coloring\n                   /  w.xyyx\n                   // Accretion disk brightness\n                   / ( 2. + i*i/4. - i )\n                   // Center darkness\n                   / ( .5 + 1. / a )\n                   // Rim highlight\n                   / ( .03 + abs( length(p)-.7 ) )\n             );\n    \n    // Output the color with effects\n    O = vec4(color, 1.0);  // Final output color\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wXf3Rj","date":"1743183440","viewed":43,"name":"Rzhis2","username":"ElSolem","description":"Rzhis-2","likes":0,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Zoom and rotate over time\n    float zoom = 1.0 + 0.5 * sin(iTime); // Zoom in and out\n    float angle = iTime * 0.2;           // Rotate over time\n    \n    // Rotate coordinates to give 3D-like effect\n    float s = sin(angle);\n    float c = cos(angle);\n    vec2 rotatedUV = vec2(\n        c * (uv.x - 0.5) - s * (uv.y - 0.5) + 0.5,\n        s * (uv.x - 0.5) + c * (uv.y - 0.5) + 0.5\n    );\n    \n    // Apply zoom (scale uv coordinates)\n    vec2 zoomedUV = (rotatedUV - 0.5) * zoom + 0.5;\n    \n    // Apply the equation: sin(xy) * cos(-1/12) = tan(-1/12 * (x/y))\n    float x = zoomedUV.x * 3.0; // Scale for x-coordinate\n    float y = zoomedUV.y * 3.0; // Scale for y-coordinate\n\n    // Left side and right side of the equation\n    float leftSide = sin(x * y) * cos(-1.0 / 12.0); // sin(xy) * cos(-1/12)\n    float rightSide = tan((-1.0 / 12.0) * (x / y)); // tan(-1/12 * (x/y))\n\n    // Calculate the difference between the left and right sides\n    float diff = abs(leftSide - rightSide);\n\n    // Define a tolerance for when the equation is \"close enough\"\n    bool equationTrue = (diff < 0.01);\n\n    // Color change based on the equation match\n    vec3 color = vec3(0.0); // Default black if the equation is not satisfied\n    if (equationTrue)\n    {\n        // Color varies based on time\n        color = vec3(sin(iTime * 0.5), cos(iTime * 0.3), sin(iTime * 0.8));\n    }\n\n    // Final output\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"t3fGzj","date":"1743184097","viewed":54,"name":"Rzhis3","username":"ElSolem","description":"Rzhis3","likes":1,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float d) {\n    return mix(vec3(0.1, 0.6, 0.8), vec3(1.0, 0.5, 0.0), d);  // More vibrant color palette\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Convert pixel coordinates to normalized space (-1 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Apply rotation and zoom over time\n    uv = rotate(uv, iTime * 0.2);         // Rotation\n    float zoom = 1.0 + 0.5 * sin(iTime);  // Zoom in/out effect\n    uv *= zoom;  // Apply zoom\n\n    // Calculate the equation: sin(xy) * cos(-1/12) = tan(-1/12 * (x/y))\n    float x = uv.x * 3.0;\n    float y = uv.y * 3.0;\n\n    float leftSide = sin(x * y) * cos(-1.0 / 12.0);  // sin(xy) * cos(-1/12)\n    float rightSide = tan((-1.0 / 12.0) * (x / y)); // tan(-1/12 * (x/y))\n    \n    // Calculate the difference between left and right sides\n    float diff = abs(leftSide - rightSide);\n\n    // Define a threshold for when the equation is \"close enough\"\n    bool equationTrue = (diff < 0.01); // Allow a small difference for plotting points\n\n    // Color dynamic change over time\n    vec3 color = vec3(0.0);  // Default black color\n    if (equationTrue) {\n        color = palette(abs(sin(iTime * 0.5))); // Color changes over time\n    }\n\n    // Output color\n    fragColor = vec4(color, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"DdKfDt","date":"1698771284","viewed":65,"name":"Soul of Sarah I","username":"ElSolem","description":"https://www.shadertoy.com/view/DdyBDd\nxy = p.x / p.y :: secret sauce\nhttps://www.shadertoy.com/view/ddGBWd\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\nfloat redMultiplier = 0.1;\nfloat greenMultiplier = 1.1;\nfloat blueMultiplier = 1.1;\nfloat angle = 1.11;\n    vec2 normalizedCoord  = fragCoord/iResolution.xy*2.0-1.0;\n   normalizedCoord= fract(normalizedCoord * 0.5) - 0.5;\n\nfor(float i = 0.0; i<18.0; i+=1.0){\n normalizedCoord =abs(normalizedCoord );\n normalizedCoord -=0.6;\n  normalizedCoord *=1.3;\n  normalizedCoord *= mat2(\n  cos(angle),-sin(angle),\n  sin(angle),cos(angle)\n  );\n}\n  \n    fragColor = vec4(length(normalizedCoord)*redMultiplier,length(normalizedCoord)*greenMultiplier,length(normalizedCoord)*blueMultiplier,1.0);\n    }\n    else\n    {\nfloat angle = 5.0+iTime*0.01;\nvec2 normalizedCoord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\nfor(float i = 0.0; i< 16.0; i+=1.0){\n normalizedCoord =abs(normalizedCoord );\n normalizedCoord -=0.6;\n  normalizedCoord *=1.3;\n  normalizedCoord *= mat2(\n  cos(angle),-sin(angle),\n  sin(angle),cos(angle)\n  );\n}\n\n\n    fragColor = vec4(cos(length(normalizedCoord+vec2(.5,-0.7))),cos(length(normalizedCoord+vec2(0.2,-0.3))),length(normalizedCoord+vec2(-0.4,-0.1)),1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"csKfDt","date":"1698771641","viewed":90,"name":"Soul of Sarah II","username":"ElSolem","description":"https://www.shadertoy.com/view/dsyfWt\nxy = p.x / p.y :: secret sauce\nhttps://www.shadertoy.com/view/msGBDt","likes":2,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 pal( in float t)\n{\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.0,0.0);\n    vec3 d = vec3(0.5,0.20,0.25);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\nvec2 normalizedCoord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\nfor(float i = 0.0; i< 19.0; i+=1.0){\n normalizedCoord =abs(normalizedCoord );\n normalizedCoord -=0.6;\n  normalizedCoord *=1.3;\n  normalizedCoord *= mat2(\n  cos(0.2),-sin(0.2),\n  sin(0.2),cos(0.2)\n  );\n}\n    normalizedCoord *= mat2(\n sin(0.3),cos(0.3),\n  cos(0.3),sin(0.3)\n  );\n    fragColor = vec4(0,length(normalizedCoord),length(normalizedCoord),1.0);\n    }\n    else\n    {\nfloat angle = iTime*0.01;\nvec2 normalizedCoord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\nfor(float i = 0.0; i< 19.0; i+=1.0){\n normalizedCoord =abs(normalizedCoord );\n normalizedCoord -=0.6;\n  normalizedCoord *=1.3;\n  normalizedCoord *= mat2(\n  cos(angle),-sin(angle),\n  sin(angle),cos(angle)\n  );\n}\n\n    fragColor = vec4(length(normalizedCoord+vec2(-.5,-0.7)),length(normalizedCoord+vec2(0.2,-0.3)),length(normalizedCoord+vec2(-0.4,-0.1)),1.0);\n}\n    }","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"cdVBDt","date":"1698769319","viewed":1348,"name":"Taste of the Divine","username":"ElSolem","description":"If you saw what was here before no you didnt. Loll\nxy = x/y :: secret sauce\nhttps://cineshader.com/view/cdVBDt","likes":10,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float Colsinx = sin(uv.x + iTime);\n    float Colsiny = sin(uv.y + iTime);\n    float sinparty = sin((Colsinx * Colsiny) * iTime);\n    float sinpeace = sin((Colsinx / Colsiny) * iTime);\n    \n    // Ensure the exponents are being applied properly\n    float tanparty = pow(uv.x * uv.y, 6.0);  // Exponent of 6 for uv.x * uv.y\n    float tanpeace = pow(uv.x / uv.y, 0.33);  // Exponent of 0.33 for uv.x / uv.y\n\n    if (tan(tanparty) == tan(tanpeace))\n    {\n        // Output to screen\n        fragColor = vec4(Colsinx, Colsiny, sinpeace, sinpeace);\n    }\n    else\n    {\n        fragColor = vec4(Colsiny, Colsinx, sinparty, sinparty);\n    }\n}","name":"Image","description":"","type":"image"}]}]